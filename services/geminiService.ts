
import { backend } from './backend';
import { WorkspaceMode } from '../components/AnimationMaker/types';

// Types
export interface CategorySuggestion {
  title: string;
  description: string;
}

// Helper to extract text from response
const getText = (response: any): string => {
    if (!response) return "";
    if (response.text) return response.text;
    if (response.candidates && response.candidates[0] && response.candidates[0].content && response.candidates[0].content.parts) {
        return response.candidates[0].content.parts.map((p: any) => p.text).join('');
    }
    return "";
};

// Helper to extract JSON
const getJSON = (text: string): any => {
    try {
        const match = text.match(/```json\n([\s\S]*?)\n```/) || text.match(/```([\s\S]*?)```/);
        const jsonStr = match ? match[1] : text;
        return JSON.parse(jsonStr);
    } catch (e) {
        console.error("JSON Parse Error", e);
        return null;
    }
};

export const fixThreeJSCode = async (code: string, error: string): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `Fix the following Three.js code which produced this runtime error: "${error}".
        
        CRITICAL RULES:
        1. Fix the specific error mentioned.
        2. DO NOT delete existing logic or features unless they are the cause of the error.
        3. Ensure the result is a COMPLETE, self-contained HTML file.
        4. Do NOT use import maps (they are pre-injected in this environment). Use standard imports provided in the original code.
        5. Ensure 'window.scene', 'window.camera', etc., are still assigned.
        
        Code to Fix:
        ${code}
        
        Return ONLY the fixed full HTML code.`,
        config: { thinkingConfig: { thinkingBudget: 2048 } }
    });
    
    let text = getText(response);
    text = text.replace(/```html/g, '').replace(/```/g, '');
    return text;
};

// Ecom Designer

export const analyzeProductIdentity = async (base64Images: string[]): Promise<string> => {
    // Only use first image for analysis to save tokens/bandwidth if multiple
    if (!base64Images || base64Images.length === 0) return "A generic product";

    const imagePart = {
        inlineData: {
            mimeType: 'image/jpeg',
            data: base64Images[0].split(',')[1]
        }
    };
    
    const response = await backend.ai.generateContent({
        model: 'gemini-2.5-flash-latest',
        contents: {
            role: 'user',
            parts: [
                imagePart,
                { text: "Analyze this product image. Describe its physical appearance, material, color, and key identifiable features in 2 sentences." }
            ]
        }
    });
    
    return getText(response);
};

export const generateSceneDescription = async (base64Images: string[], identity: string, intent: string): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Product Identity: ${identity}.
        User Intent: ${intent}.
        
        Create a detailed scene description for a professional product photoshoot. 
        Describe the lighting, background, props, and atmosphere. 
        Keep it concise but descriptive (approx 50 words).`
    });
    return getText(response);
};

export const generateEcommerceImage = async (
    base64Images: string[], 
    identity: string, 
    scenePrompt: string, 
    angle: string,
    aspectRatio: string,
    resolution: string
): Promise<string> => {
    if (!base64Images || base64Images.length === 0) throw new Error("No source images provided");

    // Use gemini-3-pro-image-preview for high quality
    const imagePart = {
        inlineData: {
            mimeType: 'image/jpeg',
            data: base64Images[0].split(',')[1]
        }
    };
    
    const fullPrompt = `Professional product photography. 
    Product: ${identity}.
    Scene: ${scenePrompt}.
    Camera Angle: ${angle}.
    Ensure high fidelity, photorealistic lighting, and correct perspective.`;

    const response = await backend.ai.generateContent({
        model: 'gemini-3-pro-image-preview',
        contents: {
            parts: [
                imagePart,
                { text: fullPrompt }
            ]
        },
        config: {
            imageConfig: {
                aspectRatio: aspectRatio === '1:1' ? '1:1' : aspectRatio === '16:9' ? '16:9' : '1:1',
            }
        }
    });

    // Extract image
    if (response.candidates && response.candidates[0].content.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
            }
        }
    }
    
    throw new Error("No image generated by AI.");
};


// Motion Studio

export const enhanceScenePrompt = async (prompt: string): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Enhance this 3D scene description for a generative Three.js script. Make it more descriptive about lighting, motion, and visual style: "${prompt}"`
    });
    return getText(response);
};

export const generateCreativeSceneCode = async (prompt: string, existingCode?: string, style: string = 'standard', hasImage: boolean = false): Promise<string> => {
    let systemPrompt = `You are a Three.js expert. Generate a single HTML file containing a Three.js scene.
    Style: ${style}.
    Requirements:
    1. Use standard CDN links for Three.js (unpkg or esm.sh).
    2. Include lighting, camera, and a renderer.
    3. If 'hasImage' is true, use 'window.PRODUCT_IMAGE_URL' as a texture on a central object.
    4. Make it animated and visually interesting.
    5. Handle window resize.
    6. Return ONLY the HTML code.
    `;
    
    if (existingCode) {
        systemPrompt += `\nUpdate the existing code based on the user request. Keep the structure.`;
    }

    const response = await backend.ai.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `User Prompt: ${prompt}.
        ${existingCode ? `Existing Code: \n${existingCode}` : ''}`,
        config: {
            systemInstruction: systemPrompt,
            thinkingConfig: { thinkingBudget: 4096 }
        }
    });

    let text = getText(response);
    return text.replace(/```html/g, '').replace(/```/g, '');
};

// Movie Maker

export const enhanceCinematicPrompt = async (prompt: string): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Convert this simple direction into a cinematic shot description (camera movement, lighting, focal length): "${prompt}"`
    });
    return getText(response);
};

export const generateCinematicScene = async (prompt: string, duration: number, sceneNumber: number, prevScenePrompt?: string): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `Generate Three.js code for Scene #${sceneNumber}.
        Description: ${prompt}.
        Duration: ${duration} seconds.
        ${prevScenePrompt ? `Previous Scene Context: ${prevScenePrompt}` : ''}
        
        Requirements:
        1. Self-contained HTML with Three.js.
        2. Cinematic camera animation matching the description.
        3. High quality lighting/shadows.
        4. Return ONLY HTML.`,
        config: { thinkingConfig: { thinkingBudget: 2048 } }
    });
    
    let text = getText(response);
    return text.replace(/```html/g, '').replace(/```/g, '');
};


// Animation Maker (3D Builder)

export const suggestProjectCategories = async (desc: string): Promise<CategorySuggestion[]> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Suggest 3 categories for a 3D project described as: "${desc}". Return JSON array with 'title' and 'description'.`,
        config: { responseMimeType: 'application/json' }
    });
    
    const text = getText(response);
    const result = getJSON(text);
    return Array.isArray(result) ? result : [{ title: 'General', description: 'General 3D Project' }];
};

export const enhanceUserPrompt = async (prompt: string, category: string, mode: WorkspaceMode): Promise<string> => {
    const response = await backend.ai.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Enhance this 3D modeling prompt for a ${mode} workflow in category ${category}: "${prompt}". Make it precise and technical.`
    });
    return getText(response);
};

export const generateAnimationCode = async (
    prompt: string, 
    existingCode: string | undefined, 
    imageToUse: string | undefined, 
    category: string, 
    workspaceMode: WorkspaceMode
): Promise<string> => {
    
    const systemPrompt = `You are an expert Three.js developer building a parametric 3D modeling tool.
    Mode: ${workspaceMode} (${category}).
    
    Your goal: Generate a script that constructs a 3D scene/model based on the user prompt.
    
    CRITICAL ENVIRONMENT DETAILS:
    1. The environment has a pre-loaded 'window.scene', 'window.camera', 'window.renderer', 'window.controls'.
    2. DO NOT create scene/camera/renderer. Use the existing global variables.
    3. You must create meshes/lights and add them to 'window.scene'.
    4. If the user asks for a specific shape, use Three.js geometries or CSG.
    5. If 'imageToUse' is provided, load it as a texture.
    6. Expose key parameters (like dimensions, colors) to the GUI using: 
       'new window.GUI().add(object, "prop", min, max)'.
    
    Return ONLY the code inside the script tag (or just the JS logic if updating).
    Actually, return full HTML structure but assume the driver script is injected by the host. 
    However, for simplicity in this system, provide the FULL HTML including your logic in a <script type="module">.
    The host will inject the necessary import maps and driver setup code. You focus on the logic that runs AFTER init.
    
    Use 'window.scene.add(mesh)' to show objects.
    `;

    const response = await backend.ai.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `User Prompt: ${prompt}.
        ${existingCode ? `Existing Code (Update this): \n${existingCode}` : ''}
        ${imageToUse ? 'Has Reference Image: Yes' : ''}`,
        config: {
            systemInstruction: systemPrompt,
            thinkingConfig: { thinkingBudget: 4096 }
        }
    });

    let text = getText(response);
    return text.replace(/```html/g, '').replace(/```/g, '');
};
